본 내용은 

[헤드퍼스트디자인패턴]: https://www.hanbit.co.kr/store/books/look.php?p_code=B6113501223	"designpatternbook"

 을 읽고 정리한 내용입니다.



# CH01. 디자인 패턴의 세계로 떠나기 - 디자인 패턴 소개와 전략 패턴

### “디자인 패턴은 코드가 아닌 경험을 재사용하는 것이다.”

*누군가가 이미 우리의 문제를 해결해 놓았다.*

패턴을 잘 사용하려면 패턴을 머릿속에 집어넣은 다음 애플리케이션에 **어떻게 적용할지**를 파악해야 한다.



## 예제

여러 행동(날기, 꽥꽥거리기 등)을 하는 오리가 등장하는 **오리 시뮬레이션 게임**이 있다. 이 게임을 구현하기 위한 과정을 살펴본다.



### 표준 객체지향 기법

`Duck` 이라는 **슈퍼클래스**를 만들고, 클래스를 **확장**하여 서로 다른 종류의 오리(`MallardDuck`, `RedheadDuck`, …)를 만든다.



### 문제 상황

요구사항 추가: “오리가 날 수 있어야 한다.”

→ 슈퍼클래스에 `fly()` 메서드를 추가

→ 날아서는 안되는 서브클래스에도 날아다니는 기능이 추가 되어 이상한 오리가 날아다니는 상황 발생



### 상속으로 해결하는 방법

- 날아서는 안되는 오리들의 `fly()` 메서드를 날지 못하도록 오버라이드한다.

하지만 상속은 아래와 같은 단점을 갖는다.

- 서브클래스에서 코드가 중복된다.
  - 슈퍼클래스에서 정의한 메서드의 행동과 다른 행동을 해야할 경우 서브클래스에서 오버라이드하여 작성해야 한다.
- 실행 시에 특징을 바꾸기 힘들다.
  - 정의된 행동만을 사용할 수 있다.
- 모든 오리의 행동을 알기 힘들다.
  - 다양한 오리들이 존재하는데, 이 오리 클래스들을 일일히 열어서 찾아봐야한다.
- 코드를 변경했을 때 다른 오리들에게 원치 않은 영향을 끼칠 수 있다.
  - 슈퍼클래스에 행동을 추가하면 이 행동을 안하는 서브클래스에도 이 행동이 추가된다.

앞으로 요구사항(오리의 규격)이 계속 바뀌게 된다면, 규격이 바뀔 때마다 프로그램에 추가했던 서브클래스 오리들의 메소드를 하나하나 살펴보고 상황에 따라 오버라이드해서 재정의해야한다.

모든 클래스에 날거나 꽥꽥 거리는 기능이 있어야 하는 것은 아니므로, 상속이 올바른 방법은 아니다.



### 인터페이스 설계하기

`fly()` 메소드가 들어있는 `Flyable` 인터페이스를 생성한다면, 날 수 있는 오리에게만 인터페이스를 구현하여 `fly()` 메소드를 넣을 수 있다.

`qucak()` 메소드도 마찬가지로 `Quackable` 인터페이스를 생성하여 사용할 수 있다.

하지만 인터페이스 또한 단점이 있다.

- 코드를 재사용하지 않으므로 많은 코드 중복이 발생하여 코드 관리가 어렵다.
- 같은 `fly()` 메소드여도 날아다니는 방식이 서로 다를 수 있다.



## 소프트웨어 개발 불변의 진리

소프트웨어 개발에서 절대로 바뀌지 않는 진리는 **변화**이다. 변화하고 성장하지 않는 애플리케이션은 죽고 만다.

소프트웨어를 고칠 때 기존 코드에 미치는 영향을 최소한으로 줄이면서 작업할 수 있는 방법이 있다면, 코드 작업보다도 좋은 프로그램을 만드는 데 더 많은 시간을 투자할 수 있다.



# 디자인 패턴

## [1] 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.

바뀔 수 있는 부분은 나머지 코드에 영향을 주지 않도록 **캡슐화**한다. 그러면 코드를 변경하더라도 바뀌지 않는 부분에는 영향을 미치지 않고, 그 부분만 고치거나 확장할 수 있다.

1. 오리 시뮬레이션 게임에서 변화하는 부분을 찾아 분리한다.
   - 나는 행동, 꽥꽥 거리는 행동이 변화하는 부분이다.
2. 변화하는 메소드를 슈퍼클래스에서 분리한다.
   - `fly()` 와 `quack()` 을 `Duck` 클래스로부터 분리하여 별도의 **클래스 집합**으로 분리한다.

Q. 나는 행동과 꽥꽥 거리는 행동을 구현하는 클래스 집합은 어떻게 디자인할까?

1. 최대한 유연하게 만든다.
2. Duck의 인스턴스에 행동을 할당할 수 있어야한다.
   - ex) `MallardDuck` 인스턴스를 새로 만들고 특정 형식의 나는 행동으로 초기화한다. 이후 `Duck` 클래스에 행동과 관련된 `setter` 메서드를 포함한다면, 프로그램 실행 중에도 `MallardDuck`의 나는 행동을 **동적으로** 변경할 수 있다.



## [2] 구현보다는 인터페이스에 맞춰서 프로그래밍한다.

<img src="https://user-images.githubusercontent.com/54929552/178157750-62cea968-13b2-4926-af04-73364a24115f.jpg" alt="1" style="zoom: 67%;" />![3](https://user-images.githubusercontent.com/54929552/178157754-a6917e99-8dd5-42a8-9c1a-3771bd1ed5b1.jpg)

각 행동을 인터페이스를 사용해서 구현한다. 이제 Duck 클래스는 더이상 나는 행동과 꽥꽥 거리는 행동을 구현하지 않아도된다. (구체적인 행동을 몰라도 된다 → **캡슐화**)

💡 여기서 인터페이스란, 상위 형식(supertype) 을 말하는 것으로, 자바의 **인터페이스**나 **추상클래스**와 같은 타입으로 구현할 수 있다.



### 인터페이스(상위 형식)에 맞춰서 프로그래밍한다는 것의 의미

<img src="https://user-images.githubusercontent.com/54929552/178157747-546bd938-2300-4acb-b810-17d3888c2433.jpg" alt="2" style="zoom:67%;" />

1. 변수 d를 Dog 형식(Animal 을 확장한 구상 클래스)로 선언하면, 구체적인 구현에 맞춰서 코딩해야한다.

```java
Dog d = new Dog();
d.bark();
```

2. 인터페이스와 상위 형식에 맞춰서 프로그래밍한다면, 다음과 같이 사용할 수 있다. (**다형성** 활용)

```java
Animal a = new Dog();
a.makeSound();
```

3. 상위 형식의 인스턴스를 만드는 과정을 (new Dog()) 직접 코드로 만드는 대신, 구체적으로 구현된 객체를 실행 시에 대입하는 것이 더 바람직하다.

```java
a = getAnimal();
a.makeSound();
```

> Animal 의 서브클래스 중 어떤 형식일지는 모른다. 단지 makeSound() 에 올바른 반응만 할 수 있으면 된다.



### 인터페이스에 맞춰서 오리의 행동을 구현하는 방법

- 인터페이스와 구체적인 행동을 구현하는 클래스를 작성한다.

<img src="https://user-images.githubusercontent.com/54929552/178157754-a6917e99-8dd5-42a8-9c1a-3771bd1ed5b1.jpg" alt="3" style="zoom:67%;" />

→ 다른 형식의 객체에서도 나는 행동과 꽥꽥거리는 행동을 재사용할 수 있다. ex) 나는 로켓

→ 기존의 행동 클래스를 수정하거나 날아다니는 행동을 사용하는 Duck 클래스를 전혀 건드리지 않고 새로운 행동을 추가할 수 있다.

 💡 인터페이스를 사용하면, 위에서 작성한 상속을 쓸 때의 단점을 제거하면서 **재사용**의 장점을 그대로 누릴 수 있다.



### 오리 행동 통합하기

나는 행동과 꽥꽥거리는 행동을 Duck 클래스 또는 그 서브클래스에서 정의한 메소드를 써서 구현하지 않고, 다른 클래스에 **위임**한다.



### 캡슐화된 행동 살펴보기

- A는 B이다.
  - `MallardDuck` 은 `Duck` 이다.
- A에는 B가 있다.
  - `Duck`에는 `FlyBehavior`와 `QuackBehavior` 가 있다.
- A가 B를 구현한다.
  - `FlyWithWings`가 `FlyBehavior` 를 구현한다.

<img src="https://user-images.githubusercontent.com/54929552/178157752-daa70375-dab3-4e98-9b3c-1bfb95fcda93.jpg" alt="4" style="zoom:67%;" />

## [3] 상속보다는 구성을 활용한다.

- 구성(Compositon): 두 클래스를 합치는 것

**‘A는 B이다’** 보다 **‘A에는 B가 있다.’** 가 나을 수 있다.

ex) 각 오리에는 FlyBehavior 와 QuickBehavior 가 있으며, 각각 나는 행동과 꽥꽥거리는 행동을 **위임**받는다. 즉, 오리 클래스에서는 행동을 상속 받는 대신, **구성**된 행동 객체를 부여받는다.



### 구성 활용 시 장점

- 유연성을 크게 향상 시킬 수 있다.
- 알고리즘군을 별도의 클래스 집합으로 캡슐화할 수 있다.
- 구성 요소로 사용하는 객체에서 올바른 행동 인터페이스를 구현하기만 하면 실행 시에 행동을 바꿀 수 있다.





# 전략패턴(Stratgy Pattern)

✅ **알고리즘군**을 정의하고 **캡슐화**해서 각각의 알고리즘군을 **수정**해서 쓸 수 있게 해주는 패턴. 전략 패턴을 사용하면 클라이언트로부터 **알고리즘을 분리해서 독립적으로 변경**할 수 있다.



'캡슐화'에 대해, '인터페이스 분리'에 대해 